# Solution of zhuanti of SegTree
普通线段树： 一般包含区间修改，区间查询，单点修改，单点查询，实现较为简单  
区间合并线段树：  
线段树求矩形交：  
动态开点线段树：  
```
/******************
    VJudge链接：  https://cn.vjudge.net/contest/167923
题目按CF顺序排序
******************/
```
# #A 敌兵布阵
```
/******************
     主要算法：  
******************/
```
### 题意
一道平常的线段树模板 包含区间修改和查询（sum）
### 题解
普通线段树

### 核心代码
```
/******************
。。。
******************/
```
### 错题记录
抱歉没错过

***
# #B I Hate It
```
/******************
    主要算法： 
******************/
```
### 题意
一道普通的区间最值题目，支持单点修改和区间查询最大值  
attention：修改：如果**编号**为A的同学成绩**低于数字**B，那么把A的成绩改为B  

### 题解
普通的维护，建议读入不要一个个字符读（会出人命的啊）
### 核心代码
```
/******************
。。。
******************/
```
### 错题记录
首先读错题目WA了一两次，然后没看到多组数据又WA了一两次，然后读入问题又WA了一次。。。悲剧啊~~是不是所有的错误都被我过了一遍~~
***
# #C A Simple Problem with Integers
```
/******************
      主要算法：
******************/
```
### 题意
让你维护一个支持区间查询和修改的线段树（sum）
### 题解
搞个线段树呗
### 核心代码
```
/******************
。。。
******************/
```
### 错题记录
抱歉没错过

***
# #D 	Mayor's posters
```
/******************
      主要算法：
******************/
```
### 题意
给你两个指令，1.将区间x，y之间的值都修改为C  2（只会在最后执行一次）.线段树上颜色的数量
### 题解
更新采取普通的方法，查询时遇到纯色就用used判断，如果没记录过就ans++，标记录，否则跳过，遇到杂色就继续向下
### 核心代码
```
/******************
{（这是比较低级的方法，直接打到叶节点记录，题解中的方法将在下一题使用）
	if(lc[u]==rc[u] && lc[u]==0) {if(!used[v[u]]) {used[v[u]]=1; ans++;} return;}
	pd(u);
	int mid=(l+r)/2;
	if(lc[u]!=0) query(lc[u],l,mid);
	if(rc[u]!=0) query(rc[u],mid+1,r);
}
******************/
```
### 错题记录
抱歉没错过

***
# #E Just a Hook
```
/******************
      主要算法：
******************/
```
### 题意
维护线段树，区间查询+区间修改。有三种值，初始为1，指令可修改区间内的值。  
将在最后查询整个线段树的价值（每个值有其价值）

### 题解
跟上一题几乎一样，不再赘述

### 核心代码
```
/******************
void query(int u)
{
	if(v[u]!=0) {ans+=v[u]*sz; return;}
	pd(u);
	query(u<<1); query(u<<1|1);
}
******************/
```
###错题记录
抱歉没错过

***
# #F Count the Colors
```
/******************
      主要算法：
******************/
```
### 题意


### 题解

### 核心代码
```
/******************

******************/
```
###错题记录


***
# #G Balanced Lineup
```
/******************
      主要算法：
******************/
```
### 题意
让你维护一个线段树，具有区间查询最大值和最小值的功能

### 题解
几乎模板题
### 核心代码
```
/******************
。。。
******************/
```
###错题记录
抱歉没错过

***
# #H Can you answer these queries?
```
/******************
      主要算法：
******************/
```
### 题意
维护一个线段树，具有区间修改（将区间内每个数开方），区间查询的功能

### 题解
其实就跟普通的线段树一样，加个根号处理。但必须加个优化：如果一个数（区间）被开方7次，根据数据最大值，一定变为了1，那么就不用再做它了。
### 核心代码
```
/******************
+void update(int pos,int l,int r)
 +{
 	if(cnt[pos]>=7) return;
 	if(l<=tre[pos].s && tre[pos].e<=r) cnt[pos]++;
     if(tre[pos].s==tre[pos].e) {tre[pos].sum=sqrt(tre[pos].sum); return;}
     int mid=(tre[pos].s+tre[pos].e)/2;
     if(l<=mid) update(pos*2  ,l,r); 
     if(r> mid) update(pos*2+1,l,r);
     tre[pos].sum=tre[pos*2].sum+tre[pos*2+1].sum;
     if(cnt[pos*2]>=7 && cnt[pos*2+1]>=7) cnt[pos]=7;
 }
******************/
```
###错题记录
一道恶心的题，我加了那个优化发现依旧T，结果发现时多组数据输入后没加！=EOF。。。长知识了

***
# #I Tunnel Warfare
```
/******************
      主要算法：区间合并线段树+栈
******************/
```
### 题意
给你三个指令：1：D x 摧毁x节点  
             2：Q x 查询x节点所在连贯区间的长度（被炸了就不连贯了）
             3.R 恢复醉后一个被炸的点

### 题解
区间合并线段树，维护ll和lr表示该区间连贯的1的左右端点。然后R用栈处理
### 核心代码
```
/******************
。。。
******************/
```
###错题记录
虽然没错但很不熟练，程序也借鉴了部分题解

***
# #J Assign the task
```
/******************
      主要算法：树状线段树
******************/
```
### 题意
给你颗数，给指令可修改x节点及其子树的数字，单点查询某点的值（初始为-1）.

### 题解
先按DFS序把二维的树压成一维的线段树，l,r记录每颗树所对的开始和结束节点，然后就可以开（fan）心（ren）的线段树了
### 核心代码
```
/******************
void dfs(int u,int from)//建线段树
{
	l[u]=++cnt;
	for(int i=head[u]; i ; i=nxt[i]) if(to[i]!=from) dfs(to[i],u);
	r[u]=cnt;
}
******************/
```
###错题记录
抱歉没错过

***
# #K Transformation
```
/******************
      主要算法：“裸的”线段树
******************/
```
### 题意
~~嗯这的确是裸的线段树，我还没来的及高兴就快哭了~~  
让你维护区间+ *和修改，查询区间所有点的1/2/3次方和

### 题解
一道简（e）单（xin）的模（shen）板（jing）线段树，其它的实现方法都没有变，主要的精华都集中在了calc中，它能完美解决那一坨东西。。。
### 核心代码
```
/******************
void calc(int u,int tim,int add)
{  
    int len=tre[u].e-tre[u].s+1;  
    tre[u].sum[1]=tre[u].sum[1]*tim%P;
    tre[u].sum[2]=tre[u].sum[2]*tim%P*tim%P;
    tre[u].sum[3]=tre[u].sum[3]*tim%P*tim%P*tim%P;
    tre[u].tim=(tre[u].tim*tim)%P;
    tre[u].add=((tre[u].add*tim)% P+add)%P;
      
    tre[u].sum[3]=(tre[u].sum[3] + 3*add%P*add%P *tre[u].sum[1]%P)%P;  
    tre[u].sum[3]=(tre[u].sum[3] + 3*add%P*tre[u].sum[2]%P)%P ;  
    tre[u].sum[3]=(tre[u].sum[3] + len * add%P *add %P *add%P)%P;  
      
    tre[u].sum[2]=(tre[u].sum[2] + 2*add%P *tre[u].sum[1] %P )%P;  
    tre[u].sum[2]=(tre[u].sum[2] + len*add%P*add%P)%P;  
  
    tre[u].sum[1]=(tre[u].sum[1]+len*add%P)%P;
}  
******************/
```
###错题记录
这种题错一次就会崩溃的。。。

***
# #L Vases and Flowers
```
/******************
      主要算法：一道我也不知道是什么的线段树
******************/
```
### 题意
这是一道神奇的题目  
题目背景是插花之类的。
有两个指令： 1： 从i盆花开始插，如果有插过的就跳过，一直到最后。如果一支都插不进去就输出一个句子，否则输出插花的区间（从插第一朵到插完能插的最后一朵）  
            2： clear掉区间中的所有花并输出clear掉的数量
            
### 题解
反正我就按题意做呗，，讲起来很繁琐，代码比较简单
### 核心代码
```
/******************
void update(int u)//l，r都是全局变量，因为设为函数变量会引发故障，导致一些在某一层修改的东西回到上一层就不见了
{  
	if(C<=0) return;
    if(l<=s[u]&&e[u]<=r && (sum[u]==sz || sum[u]==0))
	{
		if(sum[u]==sz) { r+=sz; if(r>n) r=n+1;}//如果此区间满了就跳过，别忘了更新r
		else 
		{
			sum[u]=sz; C-=sz;
			if(L<0) L=s[u];//第一次插就记录
			R=e[u];//扩大区间
		}
		return;
	}  
    if(!sum[u] || sum[u]==sz) pd(u);
    if(mid>=l) update(lc);
    if(mid< r) update(rc);
    pu(u);
}

******************/
```
###错题记录
一次白痴的输出错误而已。。。

***
# #M 约会安排
```
/******************
      主要算法：
******************/
```
### 题意


### 题解

### 核心代码
```
/******************

******************/
```
###错题记录

***
# #N Picture
```
/******************
      主要算法：暴力水
******************/
```
### 题意
给你一坨会黏在一起的矩形，求他们黏在一起后的周长

### 题解
本来这玩意是比较难的矩形周长交线段树，然而就被水过去了。

### 核心代码
```
/******************
 for(i=1;i<=2*n;i++)//猥琐的方法
    {
        if(h[i].flag) for(j=h[i].y1;j<h[i].y2;j++) {if(!X[j+A]) ans++; X[j+A]++;}
        else          for(j=h[i].y1;j<h[i].y2;j++) {X[j+A]--; if(!X[j+A]) ans++;}
        if(z[i].flag) for(j=z[i].y1;j<z[i].y2;j++) {if(!Y[j+A]) ans++; Y[j+A]++;}
        else          for(j=z[i].y1;j<z[i].y2;j++) {Y[j+A]--; if(!Y[j+A]) ans++;}
    }
******************/
```
###错题记录

***
# #O 覆盖的面积
```
/******************
      主要算法：线段树矩形面积交 + 离散化
******************/
```
### 题意
给你一坨矩形，求他们粘在一起后重叠的面积

### 题解
这次不能水了，只能老老实实线段树了。  
采用扫描线法从下往上扫就可以了  
attention： 1.记得在原来的基础上成功的条件是cov[u]>1.   
            2: 要把标记推到底要不然会有故障（虽然比较浪费）。

### 核心代码
```
/******************
void update(int u,int l,int r,int v)
{
	if(s[u]==e[u]) {cov[u]+=v; pu(u); return;}//推到底
	if(mid>=l) update(left,v);
	if(mid< r) update(right,v);
	pu(u);
}
******************/
```
###错题记录
抱歉没错过

***
# #P Atlantis
```
/******************
      主要算法：还是矩形面积交
******************/
```
### 题意
给你一坨矩形，求他们粘在一起后的总面积

### 题解
这题感觉还没上题难，只要普通的扫描线就可以了，不用推到底了
### 核心代码
```
/******************
void pu(int u)
 {
 	if(cov[u]) sum[u]=key[e[u]+1]-key[s[u]];// printf("%lf %d %d\n",sum[u],e[u]+1,s[u]);}
 	else if(s[u]==e[u]) sum[u]=0;
 	else sum[u]=sum[lc]+sum[rc];
 }
void update(int u,int l,int r,int v)
 {
 	if(l<=s[u] && e[u]<=r) {cov[u]+=v; pu(u); return;}
 	if(mid>=l) update(left,v);
 	if(mid< r) update(right,v);
 	pu(u);
 }
******************/
```
###错题记录
额不小心输出格式没看清楚

***
# #Q Get The Treasury
```
/******************
      主要算法：
******************/
```
### 题意


### 题解

### 核心代码
```
/******************

******************/
```
###错题记录

***
