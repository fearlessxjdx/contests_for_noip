# Solution of Contest14
[VJudge链接](https://cn.vjudge.net/contest/168561)\
[CodeForces链接](http://codeforces.com/contest/716)
## #A Crazy Computer
### Description & Solution
给出一串数，按顺序处理每个数，用计数器累计个数，当两个数之间的间隔大于一个给定的数c时，计数器清零。求最后计数器记录的个数。
### Code
```Cpp
ans=0;
lst=0;
scanf("%d%d",&n,&c);
for(int i=1,j;i<=n;i++) {
    scanf("%d",&j);
    if(j-lst>c) ans=0;
    ans+=1;
    lst=j;
}
printf("%d\n",ans);
```
***
## #B Complete the Word
### Description
输入一个缺失部分信息的字符串，仅由大写英文字母和代表缺失的`?`号构成，要求填满其中的缺失部分，使其存在一个长度26位的连续子串，其中26个字母刚好各出现一次。
### Solution
字串长度在50000以内，大可以暴力修改。
### Code
```Cpp
void check(int x) { //判断字串中从第x位开始的子串是否满足要求
    int f[30];
    for(int i=0;i<=30;i++) f[i]=0;
    for(int i=x;i<=x+25;i++) {
        if(s[i]!='?') {
            f[s[i]-'A']++;
            if(f[s[i]-'A']>1) return;
        }
    }
    int j=0;
    for(int i=x;i<=x+25;i++) {
        if(s[i]=='?') {
            while(f[j]>0) j++;
            s[i]=(char)(j+'A');
            f[j]++;
        }
    }
    print(); //输出
}
```
***
## #C Plus and Square Root
### Description
一个等级制的小游戏，初始等级为1，有一个初始值为2的数字K。现在有两种操作，一是给数字K加上当前等级数；二是给数字K开方，并使等级上升一级。但操作二有两个要求，一个是当前的K是一个完全平方数，另一个是平方之后得到的数必须是下一等级数的倍数。现在给出一个等级数N，求使其达到N+1级的操作方法。只需输出每个等级中在对K开方之前做加法的次数。
### Solution
一道典型的数论题（结论题），理清楚题意后可以得到两个关系 ```①a[i]+ans[i]*i = a[i+1]^2 ②a[i] mod i = 0```
因为第i个答案为ans[i],因此将第一个式子变形为 ```ans[i] = (a[i+1]^2 - a[i]) / i```
这个式子说明只要能满足```a[i] mod i = 0```和```a[i+1]^2 mod i = 0```的数列a[i]都能用来构造答案数列，我们可以令```a[i] = i * (i-1)```
因此答案```ans[i] = (i+1)^2*i-i+1```, 同时要注意按照这种方式构造的数列ans[1]并不满足，因此特判后进行计算即可
### Code
```Cpp
cout << 2 << endl;
for (long long i=2;i<=n;++i){
  cout << i*(i+1)*(i+1) - i + 1 << endl; 
}
```
***
## #D Complete The Graph
### Description
给出一个边权为整数的无向图，其中一些边的权值被擦除了（边权以0表示）。再给出起点S和终点T，要求给所有的被擦除的边赋上大于0的权值，使得S到T的最短路总权值恰好为L。
### Solution   
#### NO的判断方法   
如果把所有边的权值设为1仍然大于L或者所有边都为INF仍然小于L，那就是不存在的，道理细细琢磨  
#### 判断YES的办法   
##### ● 解法一(最暴力的方法)
初始可变边边权都设为1，跑一遍最短路，记最短路长度为D。枚举每一条可变边，将其权指改为L-D-1，再跑一遍最短路更新D，若D=L则出解。O(MMlogM）
##### ● 解法二(比较巧妙的二分)
先将所有可变边从图中删除(设为INF)，若最短路小于L则无解。接下去如果一条一条地添加可变边（边权为1）并更新最短路，则总会出现一条特殊的边，当你添加的它的时候会使得最短路<L，我们称其为关建边。记添加后最短路为dis,则只需修改该边边权为L-dis-1。即可出解，否则若找不到该边，则无解。
添加边的过程我们应该用二分来。O(MlogMLogM）
##### ● 解法三(更为巧妙的办法)
初始可变边边权都设为1，我们先跑一次从终点到各个顶点的最短路，求出终点到各个点的距离，设为d[x,t]  
然后再从出发点跑一边最短路，过程中更新可变边权值，设这边的两个端点为x/y,让他等于L-d[s,x]-d[y,t]。于是我们在增大边权的时候，就构造了一条权值始终大于等于L的路。
当所有可变边更新完毕后若d[s,t]=L则出解,否则无解。(MlogM)
***
## #E Digit Tree
